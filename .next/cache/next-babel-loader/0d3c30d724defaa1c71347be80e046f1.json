{"ast":null,"code":"var __jsx = React.createElement;\nimport React from 'react';\nimport { Stage, Layer, Rect, Group, Text } from 'react-konva';\nimport { useTranslation } from 'react-i18next';\nimport { SHOW } from '../../models/incident';\nimport ResizingAnchor from './ResizingAnchor/ResizingAnchor.jsx';\nimport { getInterpolatedData, INTERPOLATION_TYPE } from '../../utils/interpolationUtils';\nimport './canvas.scss';\n\nvar handleGroupDragMove = function handleGroupDragMove(e, canvasWidth, canvasHeight) {\n  if (e.target.getClassName() !== 'Group') return;\n  var group = e.target;\n  var topLeft = group.get('.topLeft')[0];\n  var rect = group.get('Rect')[0];\n  var absX;\n  var absY; // boundary\n\n  absX = topLeft.getAbsolutePosition().x;\n  absY = topLeft.getAbsolutePosition().y;\n  absX = absX < 0 ? 0 : absX;\n  absY = absY < 0 ? 0 : absY;\n  absX = absX + rect.width() > canvasWidth ? canvasWidth - rect.width() : absX;\n  absY = absY + rect.height() > canvasHeight ? canvasHeight - rect.height() : absY;\n  topLeft.setAbsolutePosition({\n    x: absX,\n    y: absY\n  });\n  group.x(topLeft.getAbsolutePosition().x);\n  group.y(topLeft.getAbsolutePosition().y);\n  topLeft.position({\n    x: 0,\n    y: 0\n  });\n};\n\nvar Canvas = function Canvas(_ref) {\n  var className = _ref.className,\n      dotLength = _ref.dotLength,\n      canvasWidth = _ref.width,\n      canvasHeight = _ref.height,\n      objects = _ref.objects,\n      played = _ref.played,\n      focusing = _ref.focusing,\n      isAdding = _ref.isAdding,\n      entities = _ref.entities,\n      annotations = _ref.annotations,\n      isEmptyCheckEnable = _ref.isEmptyCheckEnable,\n      onStageMouseDown = _ref.onStageMouseDown,\n      onGroupDragEnd = _ref.onGroupDragEnd,\n      onGroupMouseDown = _ref.onGroupMouseDown,\n      onDotDragEnd = _ref.onDotDragEnd,\n      onDotMouseDown = _ref.onDotMouseDown;\n\n  var _useTranslation = useTranslation('twoDimensionalVideo'),\n      t = _useTranslation.t;\n\n  var layerItems = [];\n  annotations.slice().reverse().forEach(function (annotationId) {\n    var _entities$annotations = entities.annotations[annotationId],\n        incidents = _entities$annotations.incidents,\n        color = _entities$annotations.color,\n        id = _entities$annotations.id,\n        name = _entities$annotations.name,\n        label = _entities$annotations.label,\n        isManipulatable = _entities$annotations.isManipulatable;\n\n    for (var i = 0; i < incidents.length; i++) {\n      var x = void 0;\n      var y = void 0;\n      var width = void 0;\n      var height = void 0;\n\n      if (played >= incidents[i].time) {\n        if (i !== incidents.length - 1 && played >= incidents[i + 1].time) {\n          continue;\n        }\n\n        if (incidents[i].status !== SHOW) break; // todo\n\n        if (i === incidents.length - 1) {\n          var _incidents$i = incidents[i];\n          x = _incidents$i.x;\n          y = _incidents$i.y;\n          width = _incidents$i.width;\n          height = _incidents$i.height;\n        } else {\n          var interpoArea = getInterpolatedData({\n            startIncident: incidents[i],\n            endIncident: incidents[i + 1],\n            currentTime: played,\n            type: INTERPOLATION_TYPE.LENGTH\n          });\n          var interpoPos = getInterpolatedData({\n            startIncident: incidents[i],\n            endIncident: incidents[i + 1],\n            currentTime: played,\n            type: INTERPOLATION_TYPE.POSITION\n          });\n          x = interpoPos.x;\n          y = interpoPos.y;\n          width = interpoArea.width;\n          height = interpoArea.height;\n        }\n\n        var fill = focusing === name ? color.replace(/,1\\)/, ',.3)') : '';\n\n        var rect = __jsx(Rect, {\n          x: 0,\n          y: 0,\n          fill: fill,\n          width: width,\n          height: height,\n          stroke: color,\n          strokeWidth: 1,\n          onFocus: function onFocus() {},\n          onMouseOver: function onMouseOver() {\n            if (!isManipulatable || isAdding) return;\n            document.body.style.cursor = 'pointer';\n          }\n        });\n\n        var labelText = __jsx(Text, {\n          offsetY: 20,\n          x: 0,\n          y: 0,\n          fontFamily: \"Arial\",\n          text: label,\n          fontSize: 16,\n          lineHeight: 1.2,\n          fill: \"#fff\"\n        });\n\n        var resizingAnchorsUI = null;\n        var resizingAnchorsData = [{\n          x: 0,\n          y: 0,\n          key: 'topLeft',\n          name: 'topLeft'\n        }, {\n          x: width,\n          y: 0,\n          key: 'topRight',\n          name: 'topRight'\n        }, {\n          x: width,\n          y: height,\n          key: 'bottomRight',\n          name: 'bottomRight'\n        }, {\n          x: 0,\n          y: height,\n          key: 'bottomLeft',\n          name: 'bottomLeft'\n        }, {\n          x: width / 2,\n          y: 0,\n          key: 'top',\n          name: 'top'\n        }, {\n          x: 0,\n          y: height / 2,\n          key: 'left',\n          name: 'left'\n        }, {\n          x: width,\n          y: height / 2,\n          key: 'right',\n          name: 'right'\n        }, {\n          x: width / 2,\n          y: height,\n          key: 'bottom',\n          name: 'bottom'\n        }];\n\n        if (isManipulatable) {\n          resizingAnchorsUI = resizingAnchorsData.map(function (data) {\n            return __jsx(ResizingAnchor, {\n              dotLength: dotLength,\n              color: color,\n              isManipulatable: isManipulatable,\n              x: data.x,\n              y: data.y,\n              key: data.key,\n              name: data.name,\n              canvasWidth: canvasWidth,\n              canvasHeight: canvasHeight,\n              onDragEnd: onDotDragEnd,\n              onMouseDown: onDotMouseDown\n            });\n          });\n        }\n\n        layerItems.push(__jsx(Group, {\n          x: x,\n          y: y,\n          key: name,\n          id: id,\n          name: name,\n          draggable: isManipulatable,\n          onMouseDown: function onMouseDown(e) {\n            var group = e.target.findAncestor('Group');\n            if (!isManipulatable) return;\n            group.moveToTop();\n            onGroupMouseDown(e);\n          },\n          onDragEnd: function onDragEnd(e) {\n            if (e.target.getClassName() !== 'Group') return;\n            onGroupDragEnd(e);\n          },\n          onDragMove: function onDragMove(e) {\n            return handleGroupDragMove(e, canvasWidth, canvasHeight);\n          }\n        }, labelText, rect, resizingAnchorsUI));\n        break;\n      }\n    }\n  });\n  return __jsx(Stage, {\n    width: canvasWidth,\n    height: canvasHeight,\n    className: \"konva-wrapper\",\n    onMouseDown: function onMouseDown(e) {\n      return onStageMouseDown(e);\n    },\n    onMouseOver: function onMouseOver() {\n      if (isAdding) {\n        document.body.style.cursor = 'crosshair';\n      }\n    },\n    onMouseLeave: function onMouseLeave() {\n      document.body.style.cursor = 'default';\n    },\n    onMouseOut: function onMouseOut() {\n      document.body.style.cursor = 'default';\n    },\n    onBlur: function onBlur() {},\n    onFocus: function onFocus() {}\n  }, isAdding && __jsx(Layer, null, __jsx(Rect, {\n    fill: \"#ffffff\",\n    width: canvasWidth,\n    height: canvasHeight,\n    opacity: 0.3\n  }), __jsx(Text, {\n    y: canvasHeight / 2,\n    width: canvasWidth,\n    text: t('canvasAddingHint'),\n    align: \"center\",\n    fontSize: 16,\n    fill: \"#fff\"\n  })), __jsx(Layer, null, layerItems));\n};\n\nCanvas.defaultProps = {\n  className: '',\n  dotLength: 6\n};\nexport default Canvas;","map":null,"metadata":{},"sourceType":"module"}